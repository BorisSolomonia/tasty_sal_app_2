name: ğŸš€ Deploy Tasty ERP

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

concurrency:
  group: deploy-tasty-erp
  cancel-in-progress: false

env:
  APP_NAME: ${{ vars.APP_NAME || 'Tasty_Erp' }}
  PROJECT_ID: ${{ vars.GCP_PROJECT_ID || 'nine-tones-bots-2025-468320' }}
  REGION: ${{ vars.AR_REGION || 'us-central1' }}
  REPOSITORY: ${{ vars.AR_REPO_NAME || 'tasty-ar' }}

jobs:
  deploy:
    name: ğŸ—ï¸ Build & Deploy
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
    
    - name: ğŸ” Debug Environment Variables
      run: |
        echo "ğŸ” Environment Variables Debug:"
        echo "APP_NAME: '${{ env.APP_NAME }}'"
        echo "PROJECT_ID: '${{ env.PROJECT_ID }}'"
        echo "REGION: '${{ env.REGION }}'"
        echo "REPOSITORY: '${{ env.REPOSITORY }}'"
        
        echo "ğŸ” GitHub Variables (raw):"
        echo "vars.APP_NAME: '${{ vars.APP_NAME }}'"
        echo "vars.GCP_PROJECT_ID: '${{ vars.GCP_PROJECT_ID }}'"
        echo "vars.AR_REGION: '${{ vars.AR_REGION }}'"
        echo "vars.AR_REPO_NAME: '${{ vars.AR_REPO_NAME }}'"
        echo "vars.VM_HOST: '${{ vars.VM_HOST }}'"
        echo "vars.VM_SSH_USER: '${{ vars.VM_SSH_USER }}'"
        
        # Check if variables are empty
        if [ -z "${{ env.REGION }}" ]; then
          echo "âŒ REGION is empty!"
        fi
        if [ -z "${{ env.PROJECT_ID }}" ]; then
          echo "âŒ PROJECT_ID is empty!"
        fi
    
    - name: ğŸ” Auth to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: â˜ï¸ Setup Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
    
    - name: ğŸ” Debug GCP Configuration
      run: |
        echo "ğŸ” GCP Configuration Debug:"
        echo "Current Project: $(gcloud config get-value project)"
        echo "Current Account: $(gcloud config get-value account)"
        
        echo "ğŸ“¦ Available Artifact Registry repositories:"
        gcloud artifacts repositories list --project=${{ env.PROJECT_ID }} || echo "âŒ Failed to list repositories"
    
    - name: ğŸ­ Create Artifact Registry Repository (if needed)
      run: |
        echo "ğŸ­ Creating Artifact Registry repository if it doesn't exist..."
        
        # Extract repository name from full path (in case AR_REPO_NAME still has full path)
        REPO_NAME=$(echo "${{ env.REPOSITORY }}" | sed 's|.*/||')
        echo "Repository name: $REPO_NAME"
        
        # Use fallback for region
        REPO_REGION="${{ env.REGION }}"
        if [ -z "$REPO_REGION" ]; then
          REPO_REGION="us-central1"
        fi
        
        gcloud artifacts repositories create $REPO_NAME \
          --repository-format=docker \
          --location=$REPO_REGION \
          --project=${{ env.PROJECT_ID }} \
          --description="Container images for ${{ env.APP_NAME }}" || {
          echo "â„¹ï¸ Repository might already exist, continuing..."
        }
        
        echo "âœ… Repository check/creation completed"
        echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV
    
    - name: ğŸ³ Configure Docker
      run: |
        echo "ğŸ³ Configuring Docker for Artifact Registry..."
        
        # Use fallback if REGION is empty
        DOCKER_REGION="${{ env.REGION }}"
        if [ -z "$DOCKER_REGION" ]; then
          echo "âš ï¸ REGION is empty, using us-central1 as fallback"
          DOCKER_REGION="us-central1"
        fi
        
        echo "Docker registry: $DOCKER_REGION-docker.pkg.dev"
        gcloud auth configure-docker $DOCKER_REGION-docker.pkg.dev --quiet
        echo "âœ… Docker configured for $DOCKER_REGION"
        
        # Store the region for later steps
        echo "DOCKER_REGION=$DOCKER_REGION" >> $GITHUB_ENV
    
    - name: ğŸ“¦ Fetch Environment Variables
      run: |
        echo "ğŸ“¦ Fetching environment from Secret Manager..."
        echo "Secret name: ${{ env.APP_NAME }}-env"
        echo "Project: ${{ env.PROJECT_ID }}"
        
        gcloud secrets versions access latest \
          --secret="${{ env.APP_NAME }}-env" \
          --project="${{ env.PROJECT_ID }}" > .env.production
        
        echo "âœ… Environment variables fetched"
        echo "ğŸ“Š Variables count: $(wc -l < .env.production)"
    
    - name: ğŸ—ï¸ Build & Push Docker Image
      run: |
        # Construct correct image path using DOCKER_REGION (lowercase)
        APP_NAME_LOWER=$(echo "${{ env.APP_NAME }}" | tr '[:upper:]' '[:lower:]')
        IMAGE_PATH="${{ env.DOCKER_REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPO_NAME }}/$APP_NAME_LOWER"
        
        echo "ğŸ—ï¸ Building Docker image..."
        echo "ğŸ“ Image path: $IMAGE_PATH"
        echo "ğŸ“ Tags: ${{ github.sha }}, latest"
        
        # Extract Firebase variables for build args (directly from file)
        echo "ğŸ“¦ Extracting build arguments from .env.production..."
        echo "ğŸ” Debug: First few lines of .env.production:"
        head -5 .env.production
        
        REACT_APP_FIREBASE_API_KEY=$(grep "^REACT_APP_FIREBASE_API_KEY=" .env.production | cut -d'=' -f2- | tr -d '"' | tr -d "'")
        REACT_APP_FIREBASE_AUTH_DOMAIN=$(grep "^REACT_APP_FIREBASE_AUTH_DOMAIN=" .env.production | cut -d'=' -f2- | tr -d '"' | tr -d "'")
        REACT_APP_FIREBASE_PROJECT_ID=$(grep "^REACT_APP_FIREBASE_PROJECT_ID=" .env.production | cut -d'=' -f2- | tr -d '"' | tr -d "'")
        REACT_APP_FIREBASE_STORAGE_BUCKET=$(grep "^REACT_APP_FIREBASE_STORAGE_BUCKET=" .env.production | cut -d'=' -f2- | tr -d '"' | tr -d "'")
        REACT_APP_FIREBASE_MESSAGING_SENDER_ID=$(grep "^REACT_APP_FIREBASE_MESSAGING_SENDER_ID=" .env.production | cut -d'=' -f2- | tr -d '"' | tr -d "'")
        REACT_APP_FIREBASE_APP_ID=$(grep "^REACT_APP_FIREBASE_APP_ID=" .env.production | cut -d'=' -f2- | tr -d '"' | tr -d "'")
        REACT_APP_API_URL=$(grep "^REACT_APP_API_URL=" .env.production | cut -d'=' -f2- | tr -d '"' | tr -d "'")
        
        echo "ğŸ“Š Build args extracted:"
        echo "- REACT_APP_FIREBASE_PROJECT_ID: '$REACT_APP_FIREBASE_PROJECT_ID'"
        echo "- REACT_APP_API_URL: '$REACT_APP_API_URL'"
        echo "- REACT_APP_FIREBASE_API_KEY length: ${#REACT_APP_FIREBASE_API_KEY}"
        
        # Fallback values if extraction fails
        if [ -z "$REACT_APP_API_URL" ]; then
          echo "âš ï¸ REACT_APP_API_URL is empty, using fallback"
          REACT_APP_API_URL="http://35.209.56.146"
        fi
        
        # Update Dockerfile ports to 3004/3005 (if not already done)
        echo "ğŸ”§ Updating Dockerfile ports..."
        if grep -q "EXPOSE 3000 3001" Dockerfile; then
          echo "Updating EXPOSE ports..."
          sed -i 's/EXPOSE 3000 3001/EXPOSE 3004 3005/' Dockerfile
        fi
        if grep -q ":3000" Dockerfile; then
          echo "Updating port 3000 references..."
          sed -i 's/:3000/:3004/g' Dockerfile
        fi
        if grep -q ":3001" Dockerfile; then
          echo "Updating port 3001 references..."
          sed -i 's/:3001/:3005/g' Dockerfile
        fi
        echo "âœ… Dockerfile updated"
        
        echo "ğŸ” Dockerfile port configuration:"
        grep -E "(EXPOSE|:300[0-9])" Dockerfile || echo "No port references found"
        
        echo "ğŸ”§ Starting Docker build..."
        echo "ğŸ“‹ Build arguments:"
        echo "  REACT_APP_FIREBASE_API_KEY: [${#REACT_APP_FIREBASE_API_KEY} chars]"
        echo "  REACT_APP_API_URL: $REACT_APP_API_URL"
        echo "  IMAGE_PATH: $IMAGE_PATH"
        
        if docker build \
          --progress=plain \
          --build-arg REACT_APP_FIREBASE_API_KEY="$REACT_APP_FIREBASE_API_KEY" \
          --build-arg REACT_APP_FIREBASE_AUTH_DOMAIN="$REACT_APP_FIREBASE_AUTH_DOMAIN" \
          --build-arg REACT_APP_FIREBASE_PROJECT_ID="$REACT_APP_FIREBASE_PROJECT_ID" \
          --build-arg REACT_APP_FIREBASE_STORAGE_BUCKET="$REACT_APP_FIREBASE_STORAGE_BUCKET" \
          --build-arg REACT_APP_FIREBASE_MESSAGING_SENDER_ID="$REACT_APP_FIREBASE_MESSAGING_SENDER_ID" \
          --build-arg REACT_APP_FIREBASE_APP_ID="$REACT_APP_FIREBASE_APP_ID" \
          --build-arg REACT_APP_API_URL="$REACT_APP_API_URL" \
          -t $IMAGE_PATH:${{ github.sha }} \
          -t $IMAGE_PATH:latest \
          .; then
          echo "âœ… Docker build successful"
        else
          echo "âŒ Docker build failed"
          echo "ğŸ” Docker system info:"
          docker system info
          echo "ğŸ” Docker version:"
          docker version
          exit 1
        fi
        
        echo "ğŸ“¤ Pushing images..."
        docker push $IMAGE_PATH:${{ github.sha }}
        docker push $IMAGE_PATH:latest
        
        echo "âœ… Images pushed successfully"
        echo "IMAGE_PATH=$IMAGE_PATH" >> $GITHUB_ENV
    
    - name: ğŸ” Debug SSH Connection
      run: |
        echo "ğŸ” SSH Connection Debug:"
        echo "VM_HOST: '${{ vars.VM_HOST }}'"
        echo "VM_SSH_USER: '${{ vars.VM_SSH_USER }}'"
        echo "SSH Key length: ${#SSH_KEY}"
        echo "SSH Key type: $(echo '${{ secrets.VM_SSH_KEY }}' | head -1)"
        
        # Create temporary SSH key file
        echo "ğŸ”‘ Creating temporary SSH key file..."
        echo '${{ secrets.VM_SSH_KEY }}' > /tmp/ssh_key
        chmod 600 /tmp/ssh_key
        
        # Validate SSH key format
        echo "ğŸ” Validating SSH key..."
        ssh-keygen -y -f /tmp/ssh_key > /tmp/public_key || echo "âŒ Invalid SSH key format"
        echo "Public key fingerprint: $(ssh-keygen -lf /tmp/ssh_key)" || echo "âŒ Could not get fingerprint"
        
        # Test SSH connectivity
        echo "ğŸ”— Testing SSH connectivity..."
        ssh -o ConnectTimeout=10 \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -i /tmp/ssh_key \
            ${{ vars.VM_SSH_USER }}@${{ vars.VM_HOST }} \
            "echo 'SSH connection successful'" || echo "âŒ SSH connection failed"
        
        # Cleanup
        rm -f /tmp/ssh_key /tmp/public_key
      env:
        SSH_KEY: ${{ secrets.VM_SSH_KEY }}

    - name: ğŸ—ï¸ Setup VM Directories
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: "35.209.56.146"
        username: "borissolomonia"
        key: ${{ secrets.VM_SSH_KEY }}
        port: 22
        timeout: 30s
        command_timeout: 60s
        script: |
          APP_NAME="${{ env.APP_NAME }}"
          echo "ğŸ—ï¸ Setting up directories for $APP_NAME..."
          
          # Create necessary directories
          sudo mkdir -p /opt/$APP_NAME/secure-docker-setup
          sudo mkdir -p /opt/$APP_NAME/infra/caddy/conf.d
          
          # Set proper ownership
          sudo chown -R $USER:$USER /opt/$APP_NAME
          
          echo "ğŸ“ Directory structure created:"
          ls -la /opt/$APP_NAME/ || echo "Directory doesn't exist yet"
          
          echo "âœ… VM directories ready"

    - name: ğŸ“¤ Upload Files to VM
      uses: appleboy/scp-action@v0.1.7
      with:
        host: "35.209.56.146"
        username: "borissolomonia"
        key: ${{ secrets.VM_SSH_KEY }}
        port: 22
        timeout: 30s
        command_timeout: 60s
        use_insecure_cipher: false
        rm: false
        strip_components: 0
        overwrite: true
        source: "secure-docker-setup/,infra/caddy/conf.d/${{ env.APP_NAME }}.caddy"
        target: /opt/${{ env.APP_NAME }}/

    - name: ğŸ” Verify File Upload
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: "35.209.56.146"
        username: "borissolomonia"
        key: ${{ secrets.VM_SSH_KEY }}
        port: 22
        timeout: 30s
        command_timeout: 60s
        script: |
          APP_NAME="${{ env.APP_NAME }}"
          echo "ğŸ” Verifying file upload for $APP_NAME..."
          
          echo "ğŸ“ Directory contents:"
          ls -la /opt/$APP_NAME/ || echo "âŒ Main directory missing"
          ls -la /opt/$APP_NAME/secure-docker-setup/ || echo "âŒ secure-docker-setup missing"
          ls -la /opt/$APP_NAME/infra/caddy/conf.d/ || echo "âŒ caddy conf.d missing"
          
          echo "ğŸ“„ Key files:"
          test -f /opt/$APP_NAME/secure-docker-setup/docker-compose.yml && echo "âœ… docker-compose.yml exists" || echo "âŒ docker-compose.yml missing"
          test -f /opt/$APP_NAME/infra/caddy/conf.d/$APP_NAME.caddy && echo "âœ… Caddy config exists" || echo "âŒ Caddy config missing"
          
          echo "âœ… File verification completed"

    - name: ğŸ“¦ Create .env file on VM from Secret Manager
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: "35.209.56.146"
        username: "borissolomonia"
        key: ${{ secrets.VM_SSH_KEY }}
        port: 22
        timeout: 60s
        command_timeout: 120s
        script: |
          set -e
          APP_NAME="${{ env.APP_NAME }}"
          PROJECT_ID="${{ env.PROJECT_ID }}"
          
          echo "ğŸ“¦ Creating .env file from Secret Manager..."
          echo "Secret name: $APP_NAME-env"
          echo "Project: $PROJECT_ID"
          echo "Target: /opt/$APP_NAME/secure-docker-setup/.env"
          
          # Fetch environment variables from Secret Manager and save to .env
          gcloud secrets versions access latest \
            --secret="$APP_NAME-env" \
            --project="$PROJECT_ID" > /tmp/raw_env
          
          echo "ğŸ”§ Cleaning .env file format..."
          # Clean the .env file: remove empty lines, comments, and fix formatting
          grep -E '^[A-Za-z_][A-Za-z0-9_]*=' /tmp/raw_env > /opt/$APP_NAME/secure-docker-setup/.env || {
            echo "âŒ No valid environment variables found!"
            echo "ğŸ” Raw content from Secret Manager:"
            cat /tmp/raw_env
            exit 1
          }
          
          # Clean up temp file
          rm -f /tmp/raw_env
          
          echo "âœ… .env file created and cleaned successfully"
          echo "ğŸ“Š Environment variables count: $(wc -l < /opt/$APP_NAME/secure-docker-setup/.env)"
          echo "ğŸ” First few lines (sanitized):"
          head -5 /opt/$APP_NAME/secure-docker-setup/.env | sed 's/=.*/=***/' || true
    
    - name: ğŸš€ Deploy Application
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: "35.209.56.146"
        username: "borissolomonia"
        key: ${{ secrets.VM_SSH_KEY }}
        port: 22
        timeout: 120s
        command_timeout: 300s
        script: |
          set -e
          
          APP_NAME="${{ env.APP_NAME }}"
          PROJECT_ID="${{ env.PROJECT_ID }}"
          REGION="${{ env.REGION }}"
          IMAGE_PATH="${{ env.IMAGE_PATH }}"
          COMMIT_SHA="${{ github.sha }}"
          
          echo "ğŸš€ Deploying $APP_NAME..."
          echo "ğŸ“ Image: $IMAGE_PATH:$COMMIT_SHA"
          echo "ğŸ“ VM Host: ${{ vars.VM_HOST }}"
          echo "ğŸ“ Current user: $(whoami)"
          echo "ğŸ“ Current directory: $(pwd)"
          
          # Error handling function
          handle_error() {
            local exit_code=$?
            local line_number=$1
            echo "âŒ Error on line $line_number: Command exited with code $exit_code"
            echo "ğŸ“‹ Recent commands:"
            history | tail -5
            exit $exit_code
          }
          
          trap 'handle_error $LINENO' ERR
          
          cd /opt/$APP_NAME
          
          # Verify .env file exists
          if [ ! -f secure-docker-setup/.env ]; then
            echo "âŒ .env file not found at secure-docker-setup/.env!"
            exit 1
          fi
          echo "ğŸ“Š Environment variables loaded: $(wc -l < secure-docker-setup/.env)"
          
          echo "ğŸ” Authenticating to Artifact Registry..."
          # Use the same region fallback
          DEPLOY_REGION="$REGION"
          if [ -z "$DEPLOY_REGION" ]; then
            DEPLOY_REGION="us-central1"
          fi
          gcloud auth configure-docker $DEPLOY_REGION-docker.pkg.dev --quiet
          
          echo "ğŸŒ Ensuring Docker network exists..."
          docker network inspect web >/dev/null 2>&1 || {
            echo "ğŸ†• Creating web network..."
            docker network create web
          }
          echo "âœ… Docker network 'web' is ready"
          
          echo "ğŸ“ Updating compose file with commit SHA..."
          
          # Verify we have the compose file
          echo "ğŸ” Checking for compose file..."
          if [ -f secure-docker-setup/docker-compose.yml ]; then
            echo "âœ… Found docker-compose.yml"
          else
            echo "âŒ docker-compose.yml not found"
            echo "ğŸ“ Available files in secure-docker-setup:"
            ls -la secure-docker-setup/ || echo "secure-docker-setup directory not found"
            echo "ğŸ“ Available files in current directory:"
            ls -la
            exit 1
          fi
          
          # Update image path in compose file (stay in parent directory)
          sed -i "s|image: .*|image: $IMAGE_PATH:$COMMIT_SHA|g" secure-docker-setup/docker-compose.yml
          
          echo "ğŸ“Š Compose file updated successfully:"
          echo "ğŸ” Image reference in compose file:"
          grep "image:" secure-docker-setup/docker-compose.yml
          
          echo "ğŸ“¦ Pulling latest image..."
          docker compose -f secure-docker-setup/docker-compose.yml --env-file secure-docker-setup/.env pull
          
          echo "ğŸ”„ Deploying application..."
          docker compose -f secure-docker-setup/docker-compose.yml --env-file secure-docker-setup/.env down --remove-orphans || true
          docker compose -f secure-docker-setup/docker-compose.yml --env-file secure-docker-setup/.env up -d
          
          echo "â³ Waiting for services to be healthy..."
          sleep 15
          
          # Use lowercase container name
          CONTAINER_NAME=$(echo "$APP_NAME" | tr '[:upper:]' '[:lower:]')
          
          echo "ğŸ“Š Container status:"
          docker ps --filter "name=$CONTAINER_NAME" --format "table {{.Names}}\t{{.Status}}\t{{.Health}}\t{{.Ports}}"
          
          echo "ğŸ”§ Ensuring container is on web network..."
          docker network connect web $CONTAINER_NAME 2>/dev/null || echo "â„¹ï¸ Container already on web network"
          
          echo "ğŸ”§ Updating Caddy configuration..."
          docker exec caddy-caddy-1 caddy reload --config /etc/caddy/Caddyfile || {
            echo "âŒ Caddy reload failed, retrying..."
            sleep 5
            docker exec caddy-caddy-1 caddy reload --config /etc/caddy/Caddyfile
          }
          
          echo "âœ… Deployment completed successfully!"
    
    - name: ğŸ” Health Check & Tests
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: "35.209.56.146"
        username: "borissolomonia"
        key: ${{ secrets.VM_SSH_KEY }}
        port: 22
        timeout: 60s
        command_timeout: 120s
        script: |
          set -e
          
          APP_NAME="${{ env.APP_NAME }}"
          
          echo "ğŸ” Running comprehensive health checks..."
          
          # Wait for services to fully start
          echo "â³ Waiting for services to stabilize..."
          sleep 15
          
          # VM internal checks
          echo "ğŸ“ VM internal health check:"
          curl -f -m 10 http://localhost/ && echo "âœ… Frontend OK" || echo "âŒ Frontend FAIL"
          curl -f -m 10 http://localhost/api/health && echo "âœ… Backend API OK" || echo "âŒ Backend API FAIL"
          curl -f -m 10 http://localhost/health/$APP_NAME && echo "âœ… Health endpoint OK" || echo "âŒ Health endpoint FAIL"
          
          # External checks
          echo "ğŸ“ External health check:"
          curl -f -m 10 http://${{ vars.VM_HOST }}/ && echo "âœ… External frontend OK" || echo "âŒ External frontend FAIL"
          curl -f -m 10 http://${{ vars.VM_HOST }}/api/health && echo "âœ… External API OK" || echo "âŒ External API FAIL"
          
          # Use lowercase container name for logs  
          CONTAINER_NAME=$(echo "$APP_NAME" | tr '[:upper:]' '[:lower:]')
          
          echo "ğŸ“‹ Application logs (last 30 lines):"
          docker logs $CONTAINER_NAME --tail 30
          
          echo "ğŸ¯ Deployment verification complete!"

    - name: ğŸ” Debug Rollback Variables
      if: failure()
      run: |
        echo "ğŸ” Rollback Debug Variables:"
        echo "vars.VM_HOST: '${{ vars.VM_HOST }}'"
        echo "vars.VM_SSH_USER: '${{ vars.VM_SSH_USER }}'"
        echo "APP_NAME: '${{ env.APP_NAME }}'"
        echo "IMAGE_PATH: '${{ env.IMAGE_PATH }}'"

    - name: âŒ Rollback on Failure
      if: failure()
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: "35.209.56.146"
        username: "borissolomonia"
        key: ${{ secrets.VM_SSH_KEY }}
        port: 22
        timeout: 60s
        command_timeout: 120s
        script: |
          APP_NAME="${{ env.APP_NAME }}"
          IMAGE_PATH="${{ env.IMAGE_PATH }}"
          
          echo "âŒ Deployment failed, initiating rollback..."
          echo "ğŸ“ Rolling back to: $IMAGE_PATH:latest"
          
          cd /opt/$APP_NAME
          
          # Rollback to latest tag
          sed -i "s|:${{ github.sha }}|:latest|g" secure-docker-setup/docker-compose.yml
          
          echo "ğŸ”„ Rolling back to previous version..."
          docker compose -f secure-docker-setup/docker-compose.yml --env-file secure-docker-setup/.env down
          docker compose -f secure-docker-setup/docker-compose.yml --env-file secure-docker-setup/.env up -d
          
          echo "ğŸ”§ Reloading Caddy..."
          docker exec caddy-caddy-1 caddy reload --config /etc/caddy/Caddyfile
          
          # Use lowercase container name for rollback  
          CONTAINER_NAME=$(echo "$APP_NAME" | tr '[:upper:]' '[:lower:]')
          
          echo "ğŸ“Š Rollback status:"
          docker ps --filter "name=$CONTAINER_NAME"
          docker logs $CONTAINER_NAME --tail 20
          
          echo "âš ï¸  Rollback completed - check logs for issues"